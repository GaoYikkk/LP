# 1 实现目标

  &nbsp;  &nbsp;  &nbsp;  &nbsp;从数据结构的角度来说，链表中包含一个或多个节点的数据容器，这些个节点通过串联形成一个完整的、可遍历的线性结构，在文本中，我们依托此结构制作一个单向链表。单向链表必须记录链表的头部元素，可以遍历链表中的所有节点。一个基本的链表结构必须提供元素的添加、删除、修改、查找以及遍历功能。

  &nbsp;  &nbsp;  &nbsp;  &nbsp;为了方便链表的使用，还应该提供链表信息获取等扩展方法，这些方法包含并不限于链表长度的获取、头元素获取、尾部元素获取、是否包含指定元素等，这些功能是一个链表应该具备的基础功能。

  &nbsp;  &nbsp;  &nbsp;  &nbsp;此外，为了能够让链表可以存储多种类型数据，应该将链表设计成泛型类。为了避免出现不符合Java约束的情况出现，我们也应该对容器内元素个数进行约束，比如给链表制定最大长度约束。
# 2 功能分析
  &nbsp;  &nbsp;  &nbsp;  &nbsp;一个链表结构中包含了若干节点，每一个节点都应包含一个存储单元，多个节点首尾相连组成一个线性数据结构，这就是链表要实现的基本结构。**由于我们的设计目标是单项链表结构，链表的节点由两部分组成：一个部分为数据区，用于存放数据元素（简称数据区）；另一个部分为链接指针域，用于保存下一个存储单元的地址（简称指针域），尾部的链表指针域应为null，不保存任何节点地址的引用，它标识整条链表的结束。链表中包含的存储单元个数用于表示链表的长度。** 链表的整体结构如下图所示，其中e表示数据区，next为指针域。
![ 图１　链表的结构
 ](https://img-blog.csdnimg.cn/20200109145144501.png)
  &nbsp;  &nbsp;  &nbsp;  &nbsp;对于链表来说，记住链表的头部节点是非常重要的，只要我们记住了链表的头部节点，我们就可以获取链表上的所有元素。这也是链表遍历时重要的节点。
从容器角度来说，容器提供的主要功是数据的增、删、改、查操作，其中修改和查询操作都是在遍历链表的基础上完成的。链表上的增加和删除操作会影响链表的结构，这两个操作在进行时，我们务必要保证链表节点的之间的链接性和有效性。

## 2.1 添加新节点
  &nbsp;  &nbsp;  &nbsp;  &nbsp;在一般情况下，正常添加的链表应该在当前链表的尾部添加节点。添加节点的过程中，新节点的指针域应为null，原有的尾部节点指针域应该保存新节点地址，这样就保证了整条链表的链接是连贯的，新添加的节点是有效的。添加节点的过程如下图所示。
![图２在链表尾部添加新节点](https://img-blog.csdnimg.cn/20200109145340563.png)
  &nbsp;  &nbsp;  &nbsp;  &nbsp;在实现添加新节点的规程中，我们要从链表的头部遍历到链表的尾部，然后在尾部添加新节点。在实现的过程中，为了可以省略链表的遍历过程，我们需要记录链表的尾部节点。
## 2.2 插入新节点
  &nbsp;  &nbsp;  &nbsp;  &nbsp;在指定的节点之后添加新节点，需要获取指定节点以及前后节点的信息。然后重新对节点的指针域进行处理，其结构改变如下图所示。
![图３　在链表中插入节点](https://img-blog.csdnimg.cn/20200109145450882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3lfa2tr,size_16,color_FFFFFF,t_70)
  &nbsp;  &nbsp;  &nbsp;  &nbsp;如果在节点为e2和e3之间添加新节点n，n节点添加前后关系变化如下：

 - 添加节点前的关系为：e2.next=e3。 
 - 添加节点后的关系应为e2.next=n和n.next=e3。

## 2.3 删除链表中节点
  &nbsp;  &nbsp;  &nbsp;  &nbsp;删除节点时，需要给出要删除节点的位置，然后将该节点删除，并同时修改被删除节点前一个节点的指针域信息，如下图所示。
![图４　删除链表中的节点](https://img-blog.csdnimg.cn/20200109145954904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3lfa2tr,size_16,color_FFFFFF,t_70)
  &nbsp;  &nbsp;  &nbsp;  &nbsp;如被删除节点为e3，e3的前节点为e2，e3的后节点为e4，在删除的过程中，它们的关系有如下变化：

 - 删除前e2.next=e3,e3.next=e4
 - 删除后e2.next=e4
当被删除的节点是链表的两端时，还要及时的更新链表的头尾节点信息。

## 2.4 链表遍历
  &nbsp;  &nbsp;  &nbsp;  &nbsp;我们设计的链表如果要进行遍历，可以通过节点的指针域进行遍历。遍历的过程从头部节点开始，通过指针域获取下一个节点，以此类推直到遇到指针域为null的节点为止，代表一次遍历的完成。
# 3 详细设计说明
  &nbsp;  &nbsp;  &nbsp;  &nbsp;实现功能的链表以及相关功能由两个类组成:

 - 泛型类Link，命名为Link < T >。该类是链表功能的主类，用于提供链表操作的所有功能。
 - 泛型类Node，命名为Node< T >。表示链表中的节点，该类包含数据元素信息以及指针域信息。由于该节点为Link所独，可以设计成Link的内部类。
 
  &nbsp;  &nbsp;  &nbsp;  &nbsp;每当链表中增加一个元素时，对应增加一个Node对象，Node对象包含了元素信息（泛型变量）以及另一个节点引用对象（即链表指针域，实现多个节点的链接功能）。
## 3.1 Node类的详细设计说明
  &nbsp;  &nbsp;  &nbsp;  &nbsp;Node类是为链表的节点信息，与主类Link的泛型信息应保持一致。由于该类主要用于链表节点对象声明，建议创建成为Link的内部类。其声明名称应为"static class Node<T>"。为了方便Node的使用，可以为Node增加一个构造方法用于直接初始化节点中的元素信息和指针域信息。Node类的成员变量和一个构造方法声明如下：
	
 - **T item**:变量item用于存储链表节点中的数据（数据区）。 	
 - **Node< T > next**:变量next用于存储下一个链表节点对象（指针域）。 	
   **public Node(T item,Node< T > next)**:构造方法，用于初始化Node的成员变量。

## 3.2 Link类的详细设计
  &nbsp;  &nbsp;  &nbsp;  &nbsp;Link类是实现功能的主要类，Link的声明应为"public class Link< T >"，链表的基本功能在Link类中进行实现。
### 3.2.1 Link成员变量

 - **private int size**：用于表示链表的长度，初始值为0。当链表添加和删除节点时，应该修改size的值，size值与链表的实际长度吻合。
 -  **private final int  MAX_SIZE**：用于表示链表的最大长度。该值应为合理的整型常量，链表的长度应小于该值，初始值我们可以根据需求自行定义（不要超过int的最大值）。	
 - **private  Node< T > head**：表示链表的头结点，当删除头结点时，头结点的下一个节点变为头结点，初始值为null。 
 - **private  Node< T > last**：表示链表的尾结点。当删除尾结点时，尾结点的上一个节点变为尾结点，初始值为null。

### 3.2.2 Link类方法
**1.public boolean add(T e)**

 - **方法描述**：（重载方法）向链表中添加新元素e。返回值为true表明添加成功，失败为false。
 - **实现过程**：1.先判断size>=MAX_SIZE条件是否成立，如果成立说明超出链表长度，方法返回false。2.创建新节点node，其次再判断链表中是否是空链表，如果是空链表，更新头结点和尾节点信息为node。如果不是空链表，在尾节点后添加node节点，并更新尾节点信息。size自增一个单位，方法返回true。
 
 **2.public boolean add(int index,T e)**
 - **方法描述**：（重载方法）在指定的节点index序列前插入新的元素e。返回值为true表明添加成功，失败为false。注意，该方法无法添加在尾节点之后，但可以添加在头节点之前。
 - **实现过程**：1.判断指定索引index是否在链表范围内，并且判断是否会超出链表最大长度，如果不满足条件，方法返回false。2.索引在指定范围内时，创建新节点newNode，先判断目标是否是头节点（即索引为0），如果是头节点，将创建新节点指向头节点，并更新头结点信息。3.如果不是头结点，找到索引处的节点node和索引处前一个节点preNode，再创建新节点信息，并将新节点插入在preNode和node之间，更新节点之间的关系。4.节点添加成功，size自增一个单位，并返回true。

**3.public boolean contains(Object e)**
 - **方法描述**：查询链表中是否有当前对象，对象是否相等取决于equlas方法也是我们判断链表中是否含有目标元素e的重要判断条件。返回值为true表明有该对象，没有找到则为false。
 - **实现过程**：1.遍历链表，判断遍历的元素是否与目标对象e相等，如果被遍历的节点元素与目标节点相等，方法返回true。2.如果遍历完成后，依然没有找到与目标相等的对象，方法返回false。

**4.public T get(int index)**
 - **方法描述**：返回指定序列index处的节点元素信息。如果序列不存在，方法返回null。
 -  **实现过程**：1.当序列索引index不再链表范围内，返回null。2.如果索引在正常范围内，移动到index所在的节点node处，并返回node.item。

**5.public T getHead()**:返回链表的头节点元素，如果头结点为null，返回null。
**6.public T getLast()**:返回链表的尾节点元素，如果尾结点为null，返回null。
**7.public boolean remove(int index)**
 - **方法描述**：删除指定索引index处的节点。返回值为true表明删除成功，失败为false。
 -  **实现过程**：1.当index不再链表序列中，方法返回false。2.索引指向头节点时，头节点后移，并将原头结点删除。3.获取要被删除的节点node和前一节点preNode，如果node是尾节点，更新尾节点为preNode，并删除node节点信息。如果不是尾节点，preNode指向下一个节点，并删除node节点信息。4.删除节点成功，size自减一个单位，并返回true。

**8.public int size()**:返回链表的size变量值。
